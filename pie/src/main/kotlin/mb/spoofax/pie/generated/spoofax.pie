/// Interface that Spoofax expects from a language
data Message = foreign java mb.spoofax.api.message.Msg {}
data Ast = foreign java org.spoofax.interpreter.terms.IStrategoTerm {}
data Token = foreign java mb.spoofax.api.parse.Token {}
data Styling = foreign java mb.spoofax.api.style.Styling {}

data LangId = foreign java mb.spoofax.runtime.cfg.LangId {}

data WorkspaceResult = foreign java mb.spoofax.pie.processing.WorkspaceResult {}
func createWorkspaceResult(root: path, projectResults: ProjectResult*) -> WorkspaceResult = foreign java mb.spoofax.pie.processing#createWorkspaceResult
data ProjectResult = foreign java mb.spoofax.pie.processing.ProjectResult {}
func createProjectResult(root: path, langSpecResults: DocumentResult*, legacyResults: DocumentResult*) -> ProjectResult = foreign java mb.spoofax.pie.processing#createProjectResult
data DocumentResult = foreign java mb.spoofax.pie.processing.DocumentResult {}
func createDocumentResult(document: path, messages: Message*, tokens: Token*?, ast: Ast?, styling: Styling?, constraintsSolution: FinalSolverSolution?) -> DocumentResult = foreign java mb.spoofax.pie.processing#createDocumentResult
func emptyDocumentResult(document: path) -> DocumentResult = foreign java mb.spoofax.pie.processing#emptyDocumentResult



/// Library with functions to build and use language specifications.
/// Meta-languages
// SDF3
func sdf3-to-jsglr-parse-table(langId: LangId, root: path) -> ParseTable? = foreign mb.spoofax.pie.sdf3.SDF3ToJSGLRParseTable
data Signatures = foreign java mb.spoofax.runtime.sdf3.Signatures {}
func sdf3-to-stratego-signatures(langId: LangId, root: path) -> Signatures? = foreign mb.spoofax.pie.sdf3.SDF3ToStrategoSignatures
// ESV
func esv-to-styling-rules(langId: LangId, root: path) -> StylingRules? = foreign mb.spoofax.pie.esv.ESVToStylingRules
// NaBL2
func nabl2-compile-cgen(langId: LangId, root: path) -> CGen? = foreign mb.spoofax.pie.nabl2.CompileCGen


/// Runtime
// JSGLR
data ParseTable = foreign java mb.spoofax.runtime.jsglr.Table {}
func jsglr-parse(document: path, langId: LangId, root: path, text: string, table: ParseTable) -> (Ast?, Token*?, Message*) = foreign mb.spoofax.pie.jsglr.JSGLRParse
// Style
data StylingRules = foreign java mb.spoofax.runtime.style.StylingRules {}
func spoofax-style(tokens: Token*, rules: StylingRules) -> Styling = foreign mb.spoofax.pie.style.SpoofaxStyle
// Constraint generator
data CGen = foreign java mb.spoofax.runtime.constraint.CGen {}
data GlobalConstraints = foreign java mb.nabl2.spoofax.analysis.ImmutableInitialResult {}
func cgen-global(langId: LangId, root: path) -> GlobalConstraints? = foreign mb.spoofax.pie.constraint.CGenGlobal
data DocumentConstraints = foreign java mb.nabl2.spoofax.analysis.ImmutableUnitResult {}
func cgen-document(document: path, langId: LangId, root: path, ast: Ast, globalConstraints: GlobalConstraints) -> DocumentConstraints? = foreign mb.spoofax.pie.constraint.CGenDocument
// Constraint solver
data SolverSolution = foreign java mb.nabl2.solver.ImmutableSolution {}
func csolve-global(globalConstraints: GlobalConstraints) -> SolverSolution? = foreign mb.spoofax.pie.constraint.CSolveGlobal
func csolve-document(documentConstraints: DocumentConstraints, globalConstraints: GlobalConstraints, globalSolution: SolverSolution) -> SolverSolution? = foreign mb.spoofax.pie.constraint.CSolveDocument
data FinalSolverSolution = foreign java mb.spoofax.runtime.constraint.CSolution {}
func csolve-final(project: path, documentsConstraints: SolverSolution*, globalSolution: SolverSolution) -> FinalSolverSolution? = foreign mb.spoofax.pie.constraint.CSolveFinal




/// Processing
// Foreign processing functions.
func shouldProcessDocument(document: path) -> bool = foreign java mb.spoofax.pie.processing#shouldProcessDocument
func langSpecExtensions(root: path) -> string* = foreign mb.spoofax.pie.processing.LangSpecExtensions
func isLangSpecDocument(document: path, root: path) -> bool = foreign mb.spoofax.pie.processing.IsLangSpecDocument
func langIdOfDocument(document: path, root: path) -> LangId = foreign mb.spoofax.pie.processing.LangIdOfDocument
func legacyExtensions() -> string* = foreign mb.spoofax.pie.processing.LegacyExtensions
func isLegacyDocument(document: path) -> bool = foreign mb.spoofax.pie.processing.IsLegacyDocument
// Process all projects in a workspace.
func processWorkspace(root: path) -> WorkspaceResult = {
  val projectResults = [processProject(project, root) | project <- list root with regex "^[^.]((?!src-gen).)*\$"];
  createWorkspaceResult(root, projectResults)
} @ root
// Process all documents in a project.
func processProject(project: path, root: path) -> ProjectResult = {
  val langSpecResults = [{
    if(!shouldProcessDocument(document)) {
      emptyDocumentResult(document)
    } else {
      processDocument(document, project, root)
    }
  } | document <- walk project with extensions langSpecExtensions(root)];
  val legacyResults = [{
    if(!shouldProcessDocument(document)) {
      emptyDocumentResult(document)
    } else {
      legacyProcessDocument(document, project, root)
    }
  } | document <- walk project with extensions legacyExtensions()];
  createProjectResult(project, langSpecResults, legacyResults)
} @ project
// Process an editor of the workspace.
func processEditor(document: path, project: path, root: path, text: string) -> DocumentResult = {
  if((!exists document) || !shouldProcessDocument(document)) {
    emptyDocumentResult(document)
  } else {
    if(isLangSpecDocument(document, root)) {
      processTextBuffer(document, project, root, text)
    } else {
      if(isLegacyDocument(document)) {
        legacyProcessTextBuffer(document, project, root, text)
      } else {
        emptyDocumentResult(document)
      }
    }
  }
} @ document
// Process a document.
func processDocument(document: path, project: path, root: path) -> DocumentResult = {
  val text = (read document)!;
  processTextBuffer(document, project, root, text)
} @ document
// Process a document, with a (modified) text buffer.
func processTextBuffer(document: path, project: path, root: path, text: string) -> DocumentResult = {
  val langId = langIdOfDocument(document, root);
  val (ast, tokens, messages) = parse(document, langId, root, text);
  val styling : Styling? = if(tokens == null) null else style(langId, root, tokens!);
  val constraintsSolution: FinalSolverSolution? = if(ast == null) null else solveDocument(document, langId, project, root, ast!);
  createDocumentResult(document, messages, tokens, ast, styling, constraintsSolution)
} @ document



/// Parsing
func parse(document: path, langId: LangId, root: path, text: string) -> (Ast?, Token*?, Message*) = {
  val parseTable = sdf3-to-jsglr-parse-table(langId, root);
  if(parseTable == null) {
    val emptyAst: Ast? = null;
    val emptyTokens: Token*? = null;
    val emptyMessages: Message* = [];
    return (emptyAst, emptyTokens, emptyMessages)
  };
  jsglr-parse(document, langId, root, text, parseTable!)
} @ document
/// Styling
func style(langId: LangId, root: path, tokens: Token*) -> Styling? = {
  val syntaxStyler = esv-to-styling-rules(langId, root);
  if(syntaxStyler == null) return null;
  spoofax-style(tokens, syntaxStyler!)?
}
/// Constraint solving
func solveDocument(document: path, langId: LangId, project: path, root: path, ast: Ast) -> FinalSolverSolution? = {
  val globalConstraints = cgen-global(langId, root);
  if(globalConstraints == null) return null;
  val globalSolution = csolve-global(globalConstraints!);
  if(globalSolution == null) return null;
  val documentConstraints = cgen-document(document, langId, root, ast, globalConstraints!);
  if(documentConstraints == null) return null;
  val documentSolution = csolve-document(documentConstraints!, globalConstraints!, globalSolution!);
  if(documentSolution == null) return null;
  val solution = csolve-final(project, [documentSolution!], globalSolution!);
  solution
} @ document



/// Legacy Spoofax interoperability
// Parsing
func legacy-parse(document: path, text: string) -> (Ast?, Token*?, Message*) = foreign mb.spoofax.pie.legacy.LegacyParse
// Styling
func legacy-style(document: path, tokens: Token*, ast: Ast) -> Styling = foreign mb.spoofax.pie.legacy.LegacyStyle
// Processing
func legacyProcessDocument(document: path, project: path, root: path) -> DocumentResult = {
  val text = (read document)!;
  legacyProcessTextBuffer(document, project, root, text)
} @ document
func legacyProcessTextBuffer(document: path, project: path, root: path, text: string) -> DocumentResult = {
  val (ast, tokens, messages) = legacy-parse(document, text);
  val styling: Styling? = if(ast == null || tokens == null) null else (legacy-style(document, tokens!, ast!)?);
  createDocumentResult(document, messages, tokens, ast, styling, null)
} @ document
