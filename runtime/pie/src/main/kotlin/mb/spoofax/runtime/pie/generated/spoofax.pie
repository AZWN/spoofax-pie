/// Interface that Spoofax expects from a language
data Message = foreign java mb.spoofax.runtime.model.message.Msg {}
data Ast = foreign java org.spoofax.interpreter.terms.IStrategoTerm {}
data Token = foreign java mb.spoofax.runtime.model.parse.Token {}

data Styling = foreign java mb.spoofax.runtime.model.style.Styling {}



/// Library with functions to build SDF3 and ESV specifications
data ParseTable = foreign java mb.spoofax.runtime.impl.sdf.Table {}
func sdf2table(sdfLang: SpxCoreConfig, specDir: path, mainFile: path, includedFiles: path*) -> ParseTable? = foreign mb.spoofax.runtime.pie.builder.GenerateTable
func jsglrParse(text: string, startSymbol: string, pt: ParseTable) -> (Ast?, Token*?, Message*) = foreign mb.spoofax.runtime.pie.builder.Parse

data SyntaxStyler = foreign java mb.spoofax.runtime.impl.esv.StylingRules {}
func esv2styler(esvLang: SpxCoreConfig, mainFile: path, includedFiles: path*) -> SyntaxStyler? = foreign mb.spoofax.runtime.pie.builder.GenerateStylerRules
func esvStyle(tokenStream: Token*, st: SyntaxStyler) -> Styling = foreign mb.spoofax.runtime.pie.builder.Style



/// Language specification configuration
data LangSpecConfig = foreign java mb.spoofax.runtime.impl.cfg.LangSpecConfig {
  func extensions() -> string*
  func getName() -> string?
  func getSyntaxMainFile() -> path?
  func getSyntaxStartSymbol() -> string? 
  func getSyntaxBasedStylingFile() -> path?
}

/// Spoofax Core configuration
data SpxCoreConfig = foreign java mb.spoofax.runtime.impl.cfg.SpxCoreConfig {}
func createSpxCoreConfig(langDir: path, isLangSpec: bool, extensions: string*) -> SpxCoreConfig = foreign java mb.spoofax.runtime.impl.cfg.SpxCoreConfig#create

/// Combined configuration for the entire workspace
data WorkspaceConfig = foreign java mb.spoofax.runtime.impl.cfg.WorkspaceConfig {
  func allExtensions() -> string*
  func langSpecExtensions() -> string*
  func spxCoreExtensions() -> string*
  
  func langSpecConfigForExt(extension: string) -> LangSpecConfig?
  func spxCoreConfigForExt(extension: string) -> SpxCoreConfig?
}
func langSpecConfigForPath(workspace: WorkspaceConfig, path: path) -> LangSpecConfig? = {
  val extension = path.extension();
  if(extension == null) return null;
  return workspace.langSpecConfigForExt(extension!);
}
func spxCoreConfigForpath(workspace: WorkspaceConfig, path: path) -> SpxCoreConfig? = {
  val extension = path.extension();
  if(extension == null) return null;
  return workspace.spxCoreConfigForExt(extension!);
}
func generateWorkspaceConfig(text: string, workspaceRoot: path, cfgLangConfig: SpxCoreConfig) -> WorkspaceConfig? = foreign mb.spoofax.runtime.pie.builder.GenerateWorkspaceConfig
func createWorkspaceConfig(workspaceRoot: path) -> WorkspaceConfig? = {
  // Manually create a config for the configuration language. This is required to bootstrap the language workbench.
  val cfgLang = createSpxCoreConfig(/Users/gohla/metaborg/repo/pipeline/cfg/langspec, false, ["cfg"]);
  val workspaceFile = workspaceRoot.resolve(./root/workspace.cfg);
  if(!exists workspaceFile) return null;
  val text = read workspaceFile;
  val workspaceConfig = generateWorkspaceConfig(text, workspaceRoot, cfgLang);
  return workspaceConfig;
}



/// General processing
func processWorkspace(root: path) -> (path, Token*?, Message*, Styling?)** = {
  return [processProject(root, project) | project <- list root with regex "^[^.].+\$"];
}
func processProject(root: path, project: path) -> (path, Token*?, Message*, Styling?)* = {
  val workspaceConfig = createWorkspaceConfig(root);
  if(workspaceConfig == null) return [];
  val workspace = workspaceConfig!;
  val langSpecResults = [processFileWithLangSpecConfig(file, project, workspace) | file <- walk project with extensions (workspace.langSpecExtensions())];
  val spxCoreResults = [processFileWithSpxCore(file, project, workspace) | file <- walk project with extensions (workspace.spxCoreExtensions())];
  return langSpecResults + spxCoreResults;
}
func processString(text: string, associatedFile: path, associatedProject: path, root: path) -> (Token*?, Message*, Styling?)? = {
  val workspaceConfig = createWorkspaceConfig(root);
  if(workspaceConfig == null) return null;
  val workspace = workspaceConfig!;
  
  val extension = associatedFile.extension();
  if(extension == null) return null;
  
  val langSpecConfig = workspace.langSpecConfigForExt(extension!);
  if(langSpecConfig != null) {
    return processStringWithLangSpecConfig(text, associatedProject, langSpecConfig!, workspace)?; 
  }
  val spxCoreConfig = workspace.spxCoreConfigForExt(extension!);
  if(spxCoreConfig != null) {
    return processStringWithSpxCore(text, associatedFile, spxCoreConfig!)?; 
  }
  // No config found for file, do not process file, but this does register a dependency.
  return null;
}
func emptyResult(file: path) -> (path, Token*?, Message*, Styling?) = {
  val emptyTokens: Token*? = null;
  val emptyMessages: Message* = [];
  val emptyStyling: Styling? = null;
  return (file, emptyTokens, emptyMessages, emptyStyling);
}


/// Processing of programs of language specifications
func processFileWithLangSpecConfig(file: path, project: path, workspace: WorkspaceConfig) -> (path, Token*?, Message*, Styling?) = {
  val langSpec = langSpecConfigForPath(workspace, file);
  if(langSpec != null) {
    val text = read file; // Creates a dependency to file changes
    val (tokens, messages, styling) = processStringWithLangSpecConfig(text, project, langSpec!, workspace);
    return (file, tokens, messages, styling);
  } else {
    return emptyResult(file);
  }
}
func processStringWithLangSpecConfig(text: string, associatedProject: path, langSpec: LangSpecConfig, workspace: WorkspaceConfig) -> (Token*?, Message*, Styling?) = {
  val (ast, tokenStream, messages) = parse(text, associatedProject, langSpec, workspace);
  val styling : Styling? = if(tokenStream == null) null else style(tokenStream!, langSpec, workspace);
  return (tokenStream, messages, styling);
}


func parse(text: string, associatedProject: path, langSpec: LangSpecConfig, workspace: WorkspaceConfig) -> (Ast?, Token*?, Message*) = {
  val sdfLang = workspace.spxCoreConfigForExt("sdf3");
  if(sdfLang == null) return emptyParse();
  
  val mainFile = langSpec.getSyntaxMainFile();
  val startSymbol = langSpec.getSyntaxStartSymbol();
  if(mainFile == null || startSymbol == null) return emptyParse();

  val parseTable = sdf2table(sdfLang!, associatedProject, mainFile!, []);
  if(parseTable == null) return emptyParse();
  return jsglrParse(text, startSymbol!, parseTable!);
}
func emptyParse() -> (Ast?, Token*?, Message*) = {
  val emptyAst: Ast? = null;
  val emptyTokens: Token*? = null;
  val emptyMessages: Message* = [];
  return (emptyAst, emptyTokens, emptyMessages);
}
func style(tokenStream: Token*, langSpec: LangSpecConfig, workspace: WorkspaceConfig) -> Styling? = {
  val esvLang = workspace.spxCoreConfigForExt("esv");
  if(esvLang == null) return null;
  
  val mainFile = langSpec.getSyntaxBasedStylingFile();
  if(mainFile == null) return null;

  val syntaxStyler = esv2styler(esvLang!, mainFile!, []);
  if(syntaxStyler == null) return null;
  return esvStyle(tokenStream, syntaxStyler!)?;
}



/// Spoofax Core interoperability
/// Native functions
// Parsing
func spxCoreParse(config: SpxCoreConfig, text: string) -> (Ast?, Token*?, Message*) = foreign mb.spoofax.runtime.pie.builder.core.CoreParse 

// Analysis
func spxCoreAnalyze(config: SpxCoreConfig, projectDir: path, associatedFile: path, ast: Ast) -> (Ast?, Message*) = foreign mb.spoofax.runtime.pie.builder.core.CoreAnalyze

// Transformation
data TransformGoal = foreign java org.metaborg.core.action.ITransformGoal {}
func createCompileGoal() -> TransformGoal = foreign java mb.spoofax.runtime.pie.builder.core#createCompileGoal
func createNamedGoal(name: string) -> TransformGoal = foreign java mb.spoofax.runtime.pie.builder.core#createCompileGoal
func spxCoreTransform(config: SpxCoreConfig, projectDir: path, associatedFile: path, ast: Ast, goal: TransformGoal) -> (Ast?, path?) = foreign mb.spoofax.runtime.pie.builder.core.CoreTrans

// Styling
func spxCoreStyle(config: SpxCoreConfig, tokens: Token*, ast: Ast) -> Styling = foreign mb.spoofax.runtime.pie.builder.core.CoreStyle


/// Interoperability functions
func processFileWithSpxCore(file: path, project: path, workspace: WorkspaceConfig) -> (path, Token*?, Message*, Styling?) = {
  val config = spxCoreConfigForpath(workspace, file);
  if(config != null) {
    val text = read file; // Creates a dependency to file changes
    val (tokens, messages, styling) = processStringWithSpxCore(text, file, config!);
    return (file, tokens, messages, styling);
  } else {
    return emptyResult(file);
  }
}
func processStringWithSpxCore(text: string, associatedFile: path, config: SpxCoreConfig) -> (Token*?, Message*, Styling?) = {
  val (ast, tokens, messages) = spxCoreParse(config, text);
  val styling: Styling? = if(ast == null || tokens == null) null else (spxCoreStyle(config, tokens!, ast!)?);
  return (tokens, messages, styling);
}
