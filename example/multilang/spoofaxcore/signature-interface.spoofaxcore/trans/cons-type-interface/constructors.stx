module cons-type-interface/constructors

imports
  cons-type-interface/types
  cons-type-interface/labels

signature
  namespaces
  
    Cons : string

  relations

    cons: occurrence * CONS

  name-resolution

    resolve Cons
      filter P* I* // Transitive imports. If not: sort of imported cons might not be found
      min $ < P, $ < I, P < I

rules

  declareCons : scope * TYPE * string * list(TYPE)

  declareCons(s, T, n, y) :- {a ctag}
    new ctag,
    a == arityOfSig(y),
    s -> Cons{n} with cons CONS(T, y, a, ctag),
    // Check for constructors with same name in same scope
    query cons
      filter e and { t :- t == (Cons{n}, CONS(_, _, a, _)) }
      in s |-> [_] | error $[Duplicate declaration of constructor [n]/[a].],
    // Check for constructors with same name in imported modules
    query cons
      filter resolveMatch[Cons{n}] & ~e and { t :- t == (Cons{n}, CONS(_, _, a, _)) }
      in s |-> [] | error $[Shadowing imported constructor [n]/[a].].

rules

  typeOfCons : scope * int * string -> CONS

  typeOfCons(s, a, n) = C :- {res}
    query cons
      filter resolveMatch[Cons{n}] and { t :- t == (Cons{n}, CONS(_, _, a, _)) }
      in s |-> [(_, (_, C))| _]
          | error $[Constructor [n]/[a] not declared].

//rules
//
//  arityMatch: (occurrence * CONS) * int
//  arityMatch((Cons{n}, CONS(_, _, a, _)), a).

rules

  arityOfSig : list(TYPE) -> int

  arityOfSig([]) = 0.
  arityOfSig([_]) = 1.  
  arityOfSig([h|t]) = res :- {ts}
    ts == arityOfSig(t),
    res #= ts + 1.
